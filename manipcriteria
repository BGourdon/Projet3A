# Title     : Manipulation_criteria
# Objective : Adapter le script de calcul des CD aux data MAELIA
# Created by: BGourdon
# Created on: 25/11/2020


# On veut selectionner les PA suivant (disponibles) :
# Energy Yield ; Protein Yield ; Variable costs ; Total revenue ; Workload
# Present dans le fichier datacrop :
# Energy Yield ; Protein Yield ; Variable costs ; Revenue
# Present dans le fichier "economic_info" :
# Variable costs
# Present dans le fichier "Indicators" :
# Energy Yield ; Protein Yield , Economic efficiency & Workload

# Objectif : calcul de differents CD pour chaque PA, trace des correlations entre les CD pour selection pertinente

## Etape 1 : transformation des fichiers en fichiers exploitables ####
# cf fichier main.py

# Chargement des packages

library(tidyverse)
library(reshape2)
library(cowplot)
library(magrittr)
library(ggplot2)
library(corrplot)
library(slider)
library(nlme)

# Creation des datasets ####

# Via le fichier Indicators

indicators_long <- read.csv("export_indicators.csv", dec=".", sep=";", header=T)
indicatorsPA_long <- subset(indicators, Indicator == "Economic efficiency" |
                         Indicator == "Gross margin(???/ha)" | Indicator == "Energy yield (MjKgDM/ha)" |
                         Indicator == "Protein yield (kg N/ha)" | Indicator == "Workload h/ha")

#PA : Economic efficiency, Gross margin, Energy yield, Protein yield, Workload, déjà groupé
#fonctionnement par lignes

# Fonction qui crée le fichier à utiliser ####

# Pour le fichier Indicators

indicators_large <- dcast(data = indicators, formula = Scenario + Level + Year ~ Indicator, value.var = "Value")
indicatorsPA_large <- dcast(data = indicatorsPA_long, formula = Scenario + Level + Year ~ Indicator, value.var = "Value")
colnames(indicatorsPA_large)[4:7] <- c('Economic Efficiency', 'Energy Yield', 'Protein Yield', 'Workload')

baseline <- subset(indicatorsPA_large, Scenario == "Baseline situation")
coexistence <- subset(indicatorsPA_large, Scenario == "Coexistence scenario")
complementarity <- subset(indicatorsPA_large, Scenario == "Complementarity scenario")
synergetic <- subset(indicatorsPA_large, Scenario == "Synergetic scenario")


# allPAbaseline <- subset(indicators_large, Scenario == "Baseline situation")
# allPAcoexistence <- subset(indicators_large, Scenario == "Coexistence scenario")
# allPAcomplementarity <- subset(indicators_large, Scenario == "Complementarity scenario")
# allPAsynergetic <- subset(indicators_large, Scenario == "Synergetic scenario")


# Fonctions ####

stability <- function(df, nperf){
  # df <- data
  for(i in 4:nperf){
    name <- colnames(df)[i]
    colnames(df)[i] <- "perf"

    df <- df%>%
      group_by(Level)%>%
      mutate(detrend = if(all(is.na(perf))) NA else  residuals(lm(perf ~ Year, na.action = na.exclude)))%>%# de-trended values (residuals of linear regression)
      mutate(min = min(perf, na.rm = T), max = max(perf, na.rm = T), Range = max - min)%>%  # min, max, yield range
      #mutate(min = ifelse(min == Inf, NA, min), max = ifelse(max == -Inf, NA, max), range = ifelse(max == Inf, NA, range))%>%
      mutate(VAR = var(perf, na.rm = T))%>% # variance
      mutate(RSD = abs(sd(perf, na.rm = T)/mean(perf, na.rm = T))*100)%>% # relative standard deviation
      arrange(df$Level,df$Year)%>%
      mutate(MVS = mean(abs(perf- slide_dbl(perf, mean, .before = 1, .after = 1)), na.rm = T))%>%
      ungroup()

    df <- df %>%
      group_by(Year)%>%
      mutate(EI = mean(detrend, na.rm = T))%>% # environmental index
      ungroup()

    df <- df %>%
      group_by(Level)%>%
      mutate(slopeFW = if(all(is.na(perf))) NA else abs(lm(detrend ~ EI, na.action = na.exclude)$coefficients[[2]]-1))%>% # slope of finlay-wilkinson regression
      mutate(RESf = if(all(is.na(perf))) NA else residuals(lm(perf ~ Year, na.action = na.exclude)))%>% # residuals of linear regression
      ungroup()

    colnames(df)[(ncol(df)-9):ncol(df)] <-c(paste0(name,".detrend"),paste0(name,".min"),
                                            paste0(name,".max"),paste0(name,".Range"),
                                            paste0(name,".VAR"), paste0(name, ".RSD"),
                                            paste0(name, ".MSV"),paste0(name,".EI"), paste0(name, ".slopeFW"),
                                            paste0(name,".RESf"))

    dir.create(file.path("Criteria correlation plot"), recursive = TRUE, showWarnings = TRUE)
    jpeg(paste0("Criteria correlation plot/",name,".stability_cor.jpg"), width = 17, height = 17, units = "cm", res = 300)
    corrplot(cor(df[c((ncol(df)-8): (ncol(df) - 3),(ncol(df) - 1): ncol(df))], use = "pairwise.complete.obs"))
    dev.off()

    colnames(df)[i] <- name

  }
  return(df)
}

baseline_stab <- stability(baseline, 4)
coexistence_stab <- stability(coexistence, 7)
complementarity_stab <- stability(complementarity, 7)
synergetic_stab <- stability(synergetic, 7)


recovery <- function(perf){
  # i=3
  # colnames(df)[i] <- "perf"

  dis <- which(perf < 0.75*slide_dbl(perf, mean, na.action = na.omit, .before = 2))  # Number of economic disruption
  n <-NULL
  for(i in dis){ # pour chaque disruption
    n <- c(n,
           if(length(which(perf[(i+1):length(perf)] < mean(c(lag(perf)[i], lag(perf)[i-1]), na.rm = T))) == length(perf)-i | length(perf)-i == 0) NA # if never recovery or disruption the last year of records -> NA
           else length(which(perf[(i+1):length(perf)] < mean(c(lag(perf)[i], lag(perf)[i-1]), na.rm = T)))+1)  # else count the nb of year since recovery
  } # n = 1 means that the year after, recovery as been done
  # perf
  # dis
  # n
  return(if (is.null(n)|is.na(all(n))) NA else (mean(n, na.rm =T)))
}

resistance <- function(df, nperf){
  #df <- data
  for(i in 4:nperf){
    #i=3
    name <- colnames(df)[i]
    colnames(df)[i] <- "perf"
    colnames(df)[colnames(df) == paste0(name,".detrend")] <- "detrend"

    perclow <- quantile(df$perf, .10, na.rm = T)
    perchigh <- quantile(df$perf, .80, na.rm = T)

    df <- df%>%
      group_by(Level)%>%
      mutate(probalow = length(na.omit(perf[perf < perclow]))/length(na.omit(perf)))%>%# probability of low performance level Li et al 2019
      mutate(probalow10 = dnorm((perclow - mean(perf, na.rm = T))/sd(perf, na.rm = T))*100)%>%# probability of low performance level Macholdt et al 2020
      mutate(probahigh = length(na.omit(perf[perf > perchigh]))/length(na.omit(perf)))%>%# probability of high performance level
      mutate(pi = if(all(is.na(perf)) | length(!is.na(perf)[!is.na(perf) == T]) == 1) NA else (fitted(loess(perf ~ Year, span = 0.85, na.action = na.exclude))))%>%
      mutate(loessdetrend = if(all(is.na(perf) | identical(round(perf,3),round(pi,3)))) NA else ((perf-pi)/pi))%>% # de trending with loess regression (y - fitted)/fitted
      mutate(probafail = 1/var(loessdetrend, na.rm = T))%>%# probability of failure/crash
      mutate(RESe = if(length(perf[Year == 2015]) != 0)
        (perf[Year == 2015] - mean(c(perf[Year == 2012],perf[Year == 2013],perf[Year == 2014]), na.rm = T))
        else NA)%>% # Resistance to drought (2015)
      mutate(NED = length(na.omit(perf[perf < 0.75*slide_dbl(perf, mean, na.action = na.omit, .before = 2)])))%>% # number of economic disruption
      mutate(RECOV = recovery(perf))%>%# time to recover (in years) of economic disruption
      ungroup()

    df <- df[,-ncol(df)-5]

    #dir.create(file.path("Criteria correlation plot"), recursive = TRUE)
    jpeg(paste0("Criteria correlation plot/",name,".resist_cor.jpg"), width = 17, height = 17, units = "cm", res = 300)
    corrplot(cor(df[c((ncol(df)-7): (ncol(df)-5),(ncol(df)-3): ncol(df))], use = "pairwise.complete.obs"))
    #print(cor.test(pull(df[(ncol(df)-5)]), pull(df[ncol(df)-3])))
    dev.off()

    colnames(df)[(ncol(df)-7): ncol(df)] <- c(paste0(name, ".probalow"), paste0(name, ".probalow10"),
                                              paste0(name,".probahigh"),
                                              paste0(name, ".loessdetrend"),
                                              paste0(name, ".probafail"), paste0(name, ".RESe"),
                                              paste0(name, ".NED"), paste0(name, ".RECOV"))
    colnames(df)[i] <- name
    colnames(df)[colnames(df) == "detrend"] <- paste0(name,".detrend")
  }
  return(df)
}

baseline_res <- resistance(baseline_stab, 4)
coexistence_res <- resistance(coexistence_stab, 7)
complementarity_res <- resistance(complementarity_stab, 7)
synergetic_res <- resistance(synergetic_stab, 7)

leveltrend <- function(df, nperf){
  for(i in 4:nperf){
    # df <- data
    name <- colnames(df)[i]

    colnames(df)[i] <- "perf"

    df <- df%>%
      group_by(Level)%>%
      mutate(level = mean(perf, na.rm = T))%>%# mean level
      #mutate(RD = mean(indicators_large$`Gross margin(Â€/ha)` - perf[Year %in% indicators_large$Year & Scenario %in% indicators_large$Scenario] ,na.rm = T))%>%# mean relative distance to regional GM
      mutate(INTERf = if(all(is.na(perf))) NA else lm(perf ~ Year, na.action = na.exclude)$coefficients[[1]])%>% # intercept of linear regression
      mutate(PREDf = if(all(is.na(perf))) NA else mean(fitted.values(lm(perf ~ Year, na.action = na.exclude)), na.rm = T))%>% # mean of predicted values of linear regression
      mutate(TRENDf = if(all(is.na(perf))) NA else lm(perf ~ Year, na.action = na.exclude)$coefficients[[2]])%>% # slope of linear regression
      ungroup()

    #dir.create(file.path("Criteria correlation plot"), recursive = TRUE)
    jpeg(paste0("Criteria correlation plot/",name,".trend_cor.jpg"), width = 17, height = 17, units = "cm", res = 300)
    corrplot(cor(df[(ncol(df)-3): ncol(df)], use = "pairwise.complete.obs"))
    dev.off()

    colnames(df)[(ncol(df)-3): ncol(df)] <- c(paste0(name, ".level"), paste0(name, ".INTERf"),
                                              paste0(name,".PREDf"), paste0(name,".TRENDf"))
    colnames(df)[i] <- name

    df <- df %>%
      mutate_at(vars(1:ncol(df)), ~ifelse(. == "NaN", NA, .))
  }
  return(df)
}

baseline_trend <- leveltrend(df = baseline_res, 4)
coexistence_trend <- leveltrend(df = coexistence_res, 7)
complementarity_trend <- leveltrend(complementarity_res, 7)
synergetic_trend <- leveltrend(synergetic_res, 7)

randomreg <- function(df, nperf){
  for(i in 4:nperf){
    # df <- data_trend
    slope<-NULL
    interc<-NULL
    name <- colnames(df)[i]
    colnames(df)[i] <- "perf"

    # Calcul of random residuals and slope of the individuals in the linear mixed regression
    t<-df$Year - 2012
    y<-df$perf
    indiv<-df$Level
    rand.reg<-lme(y ~ t, random = ~ 1 + t |indiv, na.action=na.exclude,
                  control=list(msMaxIter=5e8,opt="optim",msVerbose=TRUE)) # corAR1(), random = list(indiv = pdDiag(~ 1 + t))

    #Check hypothesis
    # plot(rand.reg) # homogénéité variance
    # print(qqnorm(rand.reg, ~ranef(.))) # normalité des résidus
    # print(dwtest(resid(rand.reg) ~ t)) # not correlated

    for (j in unique(indiv)){
      slope[indiv==j]<-random.effects(rand.reg)[j, 2]
      interc[indiv ==j]<-random.effects(rand.reg)[j, 1]
    }

    df <- df %>%
      mutate(RESr = if(all(is.na(perf))) NA else as.vector(residuals(rand.reg)))%>% # residuals of mixed regression
      mutate(pred = as.vector(fitted.values(rand.reg)))%>% # fitted values of mixed regression
      mutate(TRENDr = slope)%>% # slope of mixed regression
      mutate(INTERr = interc)%>% # intercept of mixed regression
      group_by(Level)%>%
      mutate(PREDr = if(all(is.na(perf))) NA else mean(pred, na.rm = T))%>%
      ungroup()

    df <- df[, -(ncol(df)-3)] # remove pred column

    colnames(df)[(ncol(df)-3): ncol(df)] <- c(paste0(name, ".RESr"), paste0(name, ".TRENDr"), paste0(name, ".INTERr"),
                                              paste0(name,".PREDr"))
    colnames(df)[i] <- name

    dir.create(file.path("Criteria mixed regression plot"), recursive = TRUE)
    jpeg(paste0("Criteria mixed regression plot/",name,".fixed_intercept_slope.jpg"), width = 19, height = 13, units = "cm", res = 300)
    plot(random.effects(rand.reg)[,1], random.effects(rand.reg)[,2], type="n", xlab="Random intersect", ylab="Random slope", main=paste("Random regression on ",name))
    text(random.effects(rand.reg)[,1], random.effects(rand.reg)[,2], rownames(random.effects(rand.reg)))
    dev.off()

  }

  return(df)

}


baseline_randomreg <- randomreg(baseline_trend, 4)
coexistence_randomreg <- randomreg(coexistence_trend, 7)
complementarity_randomreg <- randomreg(complementarity_trend, 7)
synergetic_randomreg <- randomreg(synergetic_trend, 7)

names(synergetic_randomreg)